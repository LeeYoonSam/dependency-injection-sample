# Dependency Injection with GPT

## 목차
1. [Dependency Injection(DI)이란?](#1-dependency-injectiondi란)
2. [기본 DI 구현](#2-기본-di-구현)
3. [간단한 DI 컨테이너 만들기](#3-간단한-di-컨테이너-만들기)
4. [DI 컨테이너 기능 확장](#4-di-컨테이너-기능-확장)
5. [테스트 코드 작성](#5-테스트-코드-작성)
6. [실제 DI 프레임워크 사용하기](#6-실제-di-프레임워크-사용하기)

## 1. Dependency Injection(DI)란?

Dependency Injection은 객체 지향 프로그래밍에서 객체 간의 의존성을 외부에서 주입하는 디자인 패턴입니다.DI를 사용하면 다음과 같은 이점이 있습니다:

- 코드의 재사용성 향상
- 테스트 용이성 증가
- 결합도 감소 및 유연성 증가

## 2. 기본 DI 구현

1. 인터페이스 정의하기
2. 구현 클래스 만들기
3. 의존성을 주입받는 클래스 만들기
4. 수동으로 의존성 주입하기

## [3. 간단한 DI 컨테이너 만들기](./injectron/src/main/java/com/ys/injectron/container/DIContainer.kt)

1. 의존성을 저장할 컨테이너 클래스 정의
2. 의존성 등록 메서드 구현
3. 의존성 해결 메서드 구현
4. DI 컨테이너를 사용하여 객체 생성 및 조립

### DI Container 역할
DI Container를 사용함으로써, 개발자는 비즈니스 로직에 더 집중할 수 있고, 애플리케이션의 구조를 더 유연하고 테스트하기 쉽게 만들 수 있습니다. 
특히 큰 규모의 애플리케이션에서 DI Container는 코드의 구조화와 관리를 크게 개선할 수 있습니다.

1. 객체 생성 및 수명 주기 관리:
   - 애플리케이션에서 필요한 객체들을 생성하고 관리합니다. 
   - 싱글톤, 프로토타입 등 다양한 스코프의 객체를 관리할 수 있습니다.

2. 의존성 해결:
   - 객체가 필요로 하는 의존성을 자동으로 주입합니다. 
   - 이를 통해 개발자는 객체 간의 관계를 직접 관리하지 않아도 됩니다.

3. 설정의 중앙화:
   - 애플리케이션의 설정을 한 곳에서 관리할 수 있게 합니다. 
   - 이는 코드의 유지보수성을 높이고 변경을 쉽게 만듭니다.
   
4. 테스트 용이성 증가:
   - 의존성을 쉽게 모의 객체(mock)로 대체할 수 있어 단위 테스트가 용이해집니다.

5. 결합도 감소:
   - 객체들 사이의 직접적인 의존성을 줄여 결합도를 낮춥니다.
   - 이는 코드의 유연성과 재사용성을 높입니다.

6. 관심사의 분리:
   - 객체의 생성과 사용을 분리하여 단일 책임 원칙을 지키는 데 도움을 줍니다.

## 4. DI 컨테이너 기능 확장

1. 인터페이스 기반 의존성 등록 구현
2. 복잡한 의존성 그래프 만들기
3. 생성자 주입 자동화
4. 싱글톤 스코프 구현
5. 모듈 개념 도입
6. 어노테이션 기반 의존성 주입 구현

### 1. 인터페이스 기반 의존성 등록 구현
인터페이스 기반 의존성 등록의 주요 이점은 다음과 같습니다:

1. 유연성 증가: 구현체를 쉽게 교체할 수 있습니다.
2. 테스트 용이성: 목(mock) 객체를 사용한 테스트가 쉬워집니다.
3. 결합도 감소: 구체적인 구현에 의존하지 않아 결합도가 낮아집니다.
 
인터페이스 기반 의존성 등록 방식은 DI의 핵심 개념을 잘 보여줍니다. 
이를 통해 코드의 결합도를 낮추고, 테스트 용이성을 높이며, 더 유연한 설계를 가능하게 합니다.

### 2. 복잡한 의존성 그래프를 만들기
여러 계층의 서비스와 데이터 접근 객체(DAO)를 포함하는 시나리오를 만들어보겠습니다. 
이 예제에서는 사용자 관리와 주문 처리 시스템의 일부를 구현해볼 것입니다.​​​​​​​​​​​​​​​​

이 테스트 코드는 다음과 같은 사항들을 검증합니다:

1. 복잡한 의존성 그래프가 제대로 해결되는지 확인합니다.
2. OrderService가 모든 의존성을 올바르게 사용하는지 검증합니다.
3. UserService가 자신의 의존성을 올바르게 사용하는지 확인합니다.

이 복잡한 의존성 그래프 예제는 실제 애플리케이션과 유사한 구조를 보여줍니다. 
여기서 볼 수 있는 주요 포인트는 다음과 같습니다:

1. 계층 구조: DAO, Service, 그리고 부가 서비스(EmailService, Logger)가 각각의 계층을 형성합니다.
2. 인터페이스 기반 설계: 모든 컴포넌트가 인터페이스를 통해 정의되어 있어, 구현체를 쉽게 교체할 수 있습니다.
3. 의존성 주입: 각 서비스는 생성자를 통해 의존성을 주입받습니다.
4. 중첩된 의존성: OrderService는 UserService에 의존하고, UserService는 다시 UserDao와 Logger에 의존합니다.

이러한 구조는 다음과 같은 이점을 제공합니다:

1. 테스트 용이성: 각 컴포넌트를 독립적으로 테스트할 수 있습니다.
2. 유연성: 구현체를 쉽게 교체할 수 있어 요구사항 변경에 대응하기 쉽습니다.
3. 관심사의 분리: 각 컴포넌트가 자신의 책임에만 집중할 수 있습니다.


## 5. 테스트 코드 작성

1. DI 컨테이너 단위 테스트
2. 의존성 주입 통합 테스트
3. 목(Mock) 객체를 사용한 테스트

## 6. 실제 DI 프레임워크 사용하기

1. Dagger 소개 및 기본 사용법
2. Hilt 소개 및 안드로이드에서의 활용
3. Koin 소개 및 Kotlin 프로젝트에서의 사용법
